---
## Problem Details
Title: "300. Longest Increasing Subsequence"
Difficulty: "Medium"
Primary Topic: "Dynamic Programming"
Tags: ["Array", "Binary Search", "Dynamic Programming"]
Time Complexity: O(n²)
Space Complexity: O(n²)
---

## Intuition

A 2D DP solution which use skip and take mechanism to solve the problem using the previous value and the current index.

---

## Solution

```java
class Solution {
    private int[][] memo;
    private int[] nums;
    private int n;

    public int lengthOfLIS(int[] nums) {
        n = nums.length;
        this.nums = Arrays.copyOf(nums, n + 1);
        this.nums[n] = Integer.MIN_VALUE;
        memo = new int[n + 1][n + 1];

        for (int[] i : memo) Arrays.fill(i, -1);

        return dp(0, n);
    }

    private int dp(int i, int prev) {
        if (i >= n) return 0;
        if (memo[prev][i] != -1) return memo[prev][i];

        int keep = 0;
        if (nums[prev] < nums[i]) keep = dp(i + 1, i) + 1;
        int skip = dp(i + 1, prev);

        return memo[prev][i] = Math.max(keep, skip);
    }
}
```
