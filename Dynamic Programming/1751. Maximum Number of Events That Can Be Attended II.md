---
## Problem Details
Title: "1751. Maximum Number of Events That Can Be Attended II"
Difficulty: "Hard"
Primary Topic: "Dynamic Programming"
Tags: ["Array", "Binary Search", "Dynamic Programming", "Sorting"]
Time Complexity: O(nk logn)
Space Complexity: O(nk)
---

## Intuition

Simple thought process, skip or keep a value and store the results of overlapping subproblems in a memo to use them when they are needed again.
The main part in the problem was coming up with the next index when keeping the value and the binary search system to get the next event after the current event ends, it also handles events with same start time which can be skipped sometimes if we use inbuilt java method `Arrays.binarySearch()`

---

## Solution

```java
class Solution {
    int[][] events;
    int n, k;
    int[][] memo;

    public int maxValue(int[][] events, int k) {
        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));
        this.events = events;
        this.k = k;
        n = events.length;

        memo = new int[k][n];
        for (int[] i : memo) Arrays.fill(i, -1);

        return dp(0, 0);
    }

    private int dp(int i, int l) {
        if (i >= n || l >= k) return 0;
        if (memo[l][i] != -1) return memo[l][i];
        int nexti = 0;

        nexti = findNext(events[i][1]);
        int keep = dp(nexti, l + 1) + events[i][2];
        nexti = i + 1;
        int skip = dp(nexti, l);

        return memo[l][i] = Math.max(keep, skip);
    }

    private int findNext(int endTime) {
        int l = 0, r = events.length - 1;
        int ans = events.length;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (events[mid][0] > endTime) {
                ans = mid;
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return ans;
    }
}

```
