---
## Problem Details
Title: "1235. Maximum Profit in Job Scheduling"
Difficulty: "Hard"
Primary Topic: "Dynamic Programming"
Tags: ["Array", "Binary Search", "Dynamic Programming", "Sorting"]
Time Complexity: O(n logn)
Space Complexity: O(n)
---

## Intuition

Standard DP solution which runs from 0 to maximum start time, and checks all combinations to get profits.

---

## Solution

```java
class Solution {
    int[] st;
    int[] stSorted;
    int[] et;
    int[] p;
    int[] memo;
    int n, max;
    Map<Integer, List<Integer>> map;
    
    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {
        st = startTime;
        stSorted = st.clone();
        et = endTime;
        p = profit;
        n = p.length;
        map = new HashMap<>();

        Arrays.sort(stSorted);

        max = 0;
        for (int i = 0; i < n; i++) {
            max = Math.max(st[i], max);
            List<Integer> value = map.getOrDefault(st[i], new ArrayList<>());
            value.add(i);
            map.put(st[i], value);
        }

        memo = new int[max + 1];
        Arrays.fill(memo, -1);

        return dp(stSorted[0]); 
    }

    private int dp(int i) {
        if (i > max) return 0;
        if (memo[i] != -1) return memo[i];
        int x = Arrays.binarySearch(stSorted, i + 1);
        int skip = 0;
        if (-(x + 1) < stSorted.length) skip = dp(stSorted[x < 0 ? -(x + 1) : x]);
        int keep = 0;
        List<Integer> jobs = map.getOrDefault(i, new ArrayList<>());
        for (int j : jobs) 
            keep = Math.max(keep, dp(et[j]) + p[j]);
        return memo[i] = Math.max(keep, skip);
    }
}
```
